import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:yapster/app/core/utils/supabase_service.dart';
import 'package:yapster/app/data/repositories/post_repository.dart';
import 'package:yapster/app/data/models/post_model.dart';
import 'package:yapster/app/modules/home/controllers/posts_feed_controller.dart';
import 'package:yapster/app/modules/profile/controllers/profile_posts_controller.dart';
import 'package:yapster/app/core/services/user_posts_cache_service.dart';
import 'package:yapster/app/data/providers/account_data_provider.dart';

class CreatePostController extends GetxController {
  final SupabaseService _supabase = Get.find<SupabaseService>();
  final PostRepository _postRepository = Get.find<PostRepository>();
  final UserPostsCacheService _cacheService = Get.find<UserPostsCacheService>();
  final AccountDataProvider _accountDataProvider =
      Get.find<AccountDataProvider>();
  final ImagePicker _picker = ImagePicker();

  // Text controller for post content
  final TextEditingController contentController = TextEditingController();

  // Observable variables
  final RxList<File> selectedImages = <File>[].obs;
  final RxBool isLoading = false.obs;
  final RxString postType = 'text'.obs;
  final RxBool canPost = false.obs;

  @override
  void onInit() {
    super.onInit();
    // Listen to content changes to enable/disable post button
    contentController.addListener(_updateCanPost);
  }

  @override
  void onClose() {
    contentController.dispose();
    super.onClose();
  }

  void _updateCanPost() {
    canPost.value =
        contentController.text.trim().isNotEmpty || selectedImages.isNotEmpty;
  }

  /// Pick images from gallery
  Future<void> pickImages() async {
    try {
      final List<XFile> images = await _picker.pickMultiImage(
        maxWidth: 1080,
        maxHeight: 1080,
        imageQuality: 85,
      );

      if (images.isNotEmpty) {
        // Limit to 3 images maximum
        final imagesToAdd = images.take(3 - selectedImages.length).toList();

        for (final image in imagesToAdd) {
          selectedImages.add(File(image.path));
        }

        if (selectedImages.isNotEmpty) {
          postType.value = 'image';
        }

        _updateCanPost();
      }
    } catch (e) {
      debugPrint('Error picking images: $e');
      Get.snackbar(
        'Error',
        'Failed to pick images',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  /// Remove image at index
  void removeImage(int index) {
    if (index >= 0 && index < selectedImages.length) {
      selectedImages.removeAt(index);

      if (selectedImages.isEmpty && contentController.text.trim().isNotEmpty) {
        postType.value = 'text';
      } else if (selectedImages.isEmpty &&
          contentController.text.trim().isEmpty) {
        postType.value = 'text';
      }

      _updateCanPost();
    }
  }

  /// Create and publish post
  Future<void> createPost() async {
    if (!canPost.value) return;

    try {
      isLoading.value = true;

      final currentUser = _supabase.client.auth.currentUser;
      if (currentUser == null) {
        Get.snackbar('Error', 'User not authenticated');
        return;
      }

      // Create post model
      final post = PostModel(
        id: '', // Will be generated by database
        userId: currentUser.id,
        content: contentController.text.trim(),
        postType: postType.value,
        metadata: {}, // Will be updated with image URLs after upload
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Create post with images
      final postId = await _postRepository.createPostWithImages(
        post,
        selectedImages.toList(),
      );

      if (postId != null) {
        // Create the complete post model with the generated ID
        final createdPost = post.copyWith(id: postId);

        // Add to cache immediately
        _cacheService.addPostToCache(currentUser.id, createdPost);

        // Increment post count optimistically for immediate UI feedback
        _accountDataProvider.incrementPostCount();

        // Add to profile posts controller if it exists
        if (Get.isRegistered<ProfilePostsController>(
          tag: 'profile_threads_current',
        )) {
          try {
            final profileController = Get.find<ProfilePostsController>(
              tag: 'profile_threads_current',
            );
            profileController.addNewPost(createdPost);
          } catch (e) {
            debugPrint('Error adding post to profile controller: $e');
          }
        } else if (Get.isRegistered<ProfilePostsController>(
          tag: 'profile_posts_current',
        )) {
          // Try the posts tab controller as fallback
          try {
            final profileController = Get.find<ProfilePostsController>(
              tag: 'profile_posts_current',
            );
            profileController.addNewPost(createdPost);
          } catch (e) {
            debugPrint('Error adding post to profile controller: $e');
          }
        }

        // Add to feed controller if it exists
        try {
          final feedController = Get.find<PostsFeedController>();
          feedController.addNewPost(createdPost);
        } catch (e) {
          debugPrint('Posts feed controller not found: $e');
        }

        Get.snackbar(
          'Success',
          'Post created successfully!',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.green,
          colorText: Colors.white,
        );

        // Clear form
        _clearForm();

        // Navigate back to home
        Get.back();
      } else {
        Get.snackbar(
          'Error',
          'Failed to create post',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white,
        );
      }
    } catch (e) {
      debugPrint('Error creating post: $e');
      Get.snackbar(
        'Error',
        'Failed to create post: $e',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Clear form data
  void _clearForm() {
    contentController.clear();
    selectedImages.clear();
    postType.value = 'text';
    canPost.value = false;
  }

  /// Get image layout for UI
  String getImageLayout() {
    switch (selectedImages.length) {
      case 1:
        return 'single';
      case 2:
        return 'double';
      case 3:
        return 'triple';
      default:
        return 'none';
    }
  }
}
