import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:yapster/app/data/providers/account_data_provider.dart';
import 'package:yapster/app/data/repositories/post_repository.dart';
import 'package:yapster/app/data/models/post_model.dart';
import 'package:yapster/app/core/utils/supabase_service.dart';
import 'package:yapster/app/modules/home/controllers/posts_feed_controller.dart';
import 'package:yapster/app/modules/profile/controllers/profile_posts_controller.dart';
import 'package:yapster/app/core/services/user_posts_cache_service.dart';

class CreateController extends GetxController {
  final AccountDataProvider _accountDataProvider =
      Get.find<AccountDataProvider>();
  final PostRepository _postRepository = Get.find<PostRepository>();
  final SupabaseService _supabase = Get.find<SupabaseService>();
  final UserPostsCacheService _cacheService = Get.find<UserPostsCacheService>();
  final ImagePicker _picker = ImagePicker();

  // User info - use reactive data from AccountDataProvider
  RxString get username => _accountDataProvider.username;
  RxString get userAvatar => _accountDataProvider.avatar;
  final RxBool isVerified = false.obs;

  // Post content
  final TextEditingController postTextController = TextEditingController();
  final RxString selectedPostType = 'text'.obs;
  final RxList<File> selectedImages = <File>[].obs;
  final RxBool isLoading = false.obs;
  final RxBool canPost = false.obs;

  // Media URLs
  final RxString imageUrl = ''.obs;
  final RxString gifUrl = ''.obs;
  final RxString stickerUrl = ''.obs;

  @override
  void onInit() {
    super.onInit();
    // Listen to content changes to enable/disable post button
    postTextController.addListener(_updateCanPost);
  }

  @override
  void onClose() {
    postTextController.dispose();
    super.onClose();
  }

  void _updateCanPost() {
    canPost.value =
        postTextController.text.trim().isNotEmpty || selectedImages.isNotEmpty;
  }

  void setPostType(String type) {
    selectedPostType.value = type;
  }

  /// Pick images from gallery
  Future<void> pickImages() async {
    try {
      final List<XFile> images = await _picker.pickMultiImage(
        maxWidth: 1080,
        maxHeight: 1080,
        imageQuality: 85,
      );

      if (images.isNotEmpty) {
        // Limit to 3 images maximum
        final imagesToAdd = images.take(3 - selectedImages.length).toList();

        for (final image in imagesToAdd) {
          selectedImages.add(File(image.path));
        }

        if (selectedImages.isNotEmpty) {
          selectedPostType.value = 'image';
        }

        _updateCanPost();
      }
    } catch (e) {
      debugPrint('Error picking images: $e');
      Get.snackbar(
        'Error',
        'Failed to pick images',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  /// Remove image at index
  void removeImage(int index) {
    if (index >= 0 && index < selectedImages.length) {
      selectedImages.removeAt(index);

      if (selectedImages.isEmpty && postTextController.text.trim().isNotEmpty) {
        selectedPostType.value = 'text';
      } else if (selectedImages.isEmpty &&
          postTextController.text.trim().isEmpty) {
        selectedPostType.value = 'text';
      }

      _updateCanPost();
    }
  }

  /// Create and publish post
  Future<void> createPost() async {
    if (!canPost.value) return;

    try {
      isLoading.value = true;

      final currentUser = _supabase.client.auth.currentUser;
      if (currentUser == null) {
        Get.snackbar('Error', 'User not authenticated');
        return;
      }

      // Create post model
      final post = PostModel(
        id: '', // Will be generated by database
        userId: currentUser.id,
        content: postTextController.text.trim(),
        postType: selectedPostType.value,
        metadata: {}, // Will be updated with image URLs after upload
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Create post with images
      final postId = await _postRepository.createPostWithImages(
        post,
        selectedImages.toList(),
      );

      if (postId != null) {
        // Create the complete post model with the generated ID
        final createdPost = post.copyWith(id: postId);

        // Add to cache immediately
        _cacheService.addPostToCache(currentUser.id, createdPost);

        // Add to profile posts controller if it exists
        try {
          final profileController = Get.find<ProfilePostsController>(
            tag: 'profile_threads_current',
          );
          profileController.addNewPost(createdPost);
        } catch (e) {
          debugPrint('Profile posts controller not found: $e');
        }

        // Add to feed controller if it exists
        try {
          final feedController = Get.find<PostsFeedController>();
          feedController.addNewPost(createdPost);
        } catch (e) {
          debugPrint('Posts feed controller not found: $e');
        }

        // Clear form
        _clearForm();

        // Navigate back to home
        Get.offAllNamed('/home');
      } else {
        Get.snackbar(
          'Error',
          'Failed to create post',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white,
        );
      }
    } catch (e) {
      debugPrint('Error creating post: $e');
      Get.snackbar(
        'Error',
        'Failed to create post: $e',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }

  /// Clear form data
  void _clearForm() {
    postTextController.clear();
    selectedImages.clear();
    selectedPostType.value = 'text';
    canPost.value = false;
  }

  /// Get image layout for UI
  String getImageLayout() {
    switch (selectedImages.length) {
      case 1:
        return 'single';
      case 2:
        return 'double';
      case 3:
        return 'triple';
      default:
        return 'none';
    }
  }
}
